---
title: 数据库事务
date: 2018-11-11 22:01:46
tags: 数据库
categories: 面试题
---
# 数据库事务正确执行的四个基本要素(ACID)
## 原子性(atomicity)
　　一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成， 不会结束在中间某个环节。事务在执行过程中发生错误，会被 回滚 （Rollback）到事务开 始前的状态，就像这个事务从来没有执行过一样。
## 一致性(Consistency)
　　在事务开始和完成时，数据库中的数据都保持一致的状态，数据的完整性约束没有被破坏。（事务的执行使得数据库从一种正确状态转换成另一种正确状态）。具体来说就是，比如表与表之间存在外键约束关系，那么你对数据库进行的修改操作就必需要满足约束条件，即如果你修改了一张表中的数据，那你还需要修改与之存在外键约束关系的其他表中对应的数据，以达到一致性。
## 隔离性(Isolation)
　　一个事务的执行不能被其他事务干扰。关于事务的隔离性数据库提供了四种隔离级别。
## 持久性(Durability)
　　一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，并不会被回滚。
# 并发事务带来的问题
## (1)更新丢失
　　两个事务 Tl 和 T2 读入同一数据并修改，T2 提交的结果覆盖了 Tl 提交的结果，导致 Tl 的修改被丢失。
## (2)脏读
　　事务 Tl 修改某一数据，并将其写回磁盘(事务T1还未提交)，事务 T2 读取同一数据后，Tl 由于某种原因被撤销，这时 Tl 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致，则 T2 读到的数据就为“脏”数据，即不正确的数据。
## (3)不可重复读
　　是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次相同的查询读到的数据是不一样的，因此称为是不可重复读。不可重复读的重点是修改。
## (4)幻读
　　和不可重复读类似，重点在于新增或者删除。
# 数据库事务的隔离级别
　　数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发(读)问题。
## (1)读未提交数据(Read uncommitted)
　　允许事务读取未被其他事务提交的变更，可能有脏读，不可重复读和幻读的问题。
## (2)读已提交数据(Read committed)
　　允许事务读取已经被其他事务提交的变更，可以避免脏读，可能有不可重复读和幻读的问题。
## (3)可重复读(Repeatable read，Mysql 的默认隔离级别)
　　确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新(不能禁止其他事务对数据表进行插入和删除操作)，可以避免脏读和不可重复读，可能会有幻读。
## (4)可串行化(Serializable)
　　所有事务都一个接一个地串行执行。可以避免脏读，不可重复读，幻读。
<!-- more -->
# 更改MySQL的默认事务隔离级别
　　大多数的数据库系统的默认事务隔离级别都是：Read committed，而MySQL的默认事务隔离级别是：Repeatable Read。
　　查询mysql事务的隔离级别
```mysql
select @@tx_isolation
```
　　更改事务的隔离级别
```mysql
SET session TRANSACTION ISOLATION LEVEL Serializable;
```
将MySQL中的事务隔离级别改变成：Serializable，范围是当前session。
```mysql
set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable | Serializable;
```
如果选择global，意思是此语句将应用于之后的所有session，而当前已经存在的session不受影响。
如果选择session，意思是此语句将应用于当前session内之后的所有事务。
如果什么都不写，意思是此语句将应用于当前session内的下一个还未开始的事务。
# 数据库的锁
　　锁是一种并发控制技术，锁是用来在多个用户同时访问同一个数据的时候保护数据的。
## (1)按照锁的类型(数据库的锁机制)
　　共享(S)锁(也叫读锁)：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S 锁立即被释放。在执行 select 语句的时候需要给操作对象（表或者一些记录）加上共享锁，但加锁之前需要检查是否有排他锁(X锁)，如果没有，则可以加共享锁（一个对象上可以加 n 个共享锁），否则不行。共享锁通常在执行完 select 语句之后被释放，当然也有可能是在事务结束（包括正常结束和异常结束）的时候被释放，主要取决与数据库所设置的事务隔离级别。
　　排它(X)锁(也叫写锁)：仅允许一个事务封锁此页；其他任何事务必须等到 X 锁被释放才能对该页进行访问；X 锁一直到事务结束才能被释放。执行 insert、update、delete 语句的时候需要给操作的对象加排他锁，在加排他锁之前必须确认该对象上没有其他任何锁，一旦加上排他锁之后，就不能再给这个对象加其他任何锁。排他锁的释放通常是在事务结束的时候（当然也有例外，就是在数据库事务隔离级别被设置成 Read Uncommitted（读未提交数据）的时候，这种情况下排他锁会在执行完更新操作之后就释放，而不是在事务结束的时候）。
## (2)按照锁的粒度
　　所谓粒度，即细化的程度。锁的粒度越大，则并发性越低且开销大；锁的粒度越小，则并发性高且开销小。
### 行级锁
　　仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
　　InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。(按照锁的类型，2个标准。)
### 页级锁
　　一次锁定相邻的一组记录。特点开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
### 表级锁
　　直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许。特点：开销小，加锁快；不会出现死锁；锁定粒度最大，发生锁冲突的概率最高，并发度最低。
　　有 2 种模式：表共享读锁和表独占写锁。加读锁的命令:lock table 表名 read;去掉锁的命令：unlock tables。
  　MyISAM 存储引擎采用的是表级锁。
## 锁实现：悲观锁和乐观锁
### 悲观锁
　　锁如其名，他对世界是悲观的，他认为别人访问正在改变的数据的概率是很高的，所以从数据开始更改时就将数据锁住，直到更改完成才释放。
　　特点：悲观锁可能会造成加锁的时间很长，并发性不好，特别是长事务，影响系统的整体性能。
　　悲观锁实现方式：数据库提供的锁机制。
　　１.共享锁: 阻止其他事务写表（即其他事务不能write，可以read）
```mysql
select * from table lock in share mode
```
　　２.排它锁： 阻止其他事务读、写该表(数据库默认加排它锁)
```mysql
select * from table for update
```
##＃ 乐观锁
　　乐观锁，他对世界比较乐观，认为别人访问正在改变的数据的概率是很低的，所以直到修改完成准备提交所做的修改到数据库的时候才会将数据锁住，当你读取以及改变该对象时并不加锁，完成更改后释放。乐观锁不能解决脏读的问题。
　　特点：乐观锁加锁的时间要比悲观锁短，大大提升了大并发量下的系统整体性能表现。
　　乐观锁实现方式:
　　１.大多是基于数据版本（Version）记录机制实现，需要为每一行数据增加一个版本标识（也就是每一行数据多一个字段 version），每次更新数据都要更新对应的版本号+1。
　　２.使用时间戳来实现。同样是在需要乐观锁控制的 table 中增加一个字段，名称无所谓，字段类型使用时间戳 （timestamp）, 和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。
# 解决更新丢失的方法
　　加乐观锁或者悲观锁。